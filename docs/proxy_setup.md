# Proxy Setup for QA Builds

This guide explains how to configure and use system proxies (Charles, Proxyman, Requestly) with the Esmorga Flutter app for QA builds.

## Overview

The app is configured to automatically detect and use the system proxy settings when running in the **QA environment**. This allows you to inspect network traffic, including HTTPS requests, using tools like Charles Proxy, Proxyman, or Requestly.

## Prerequisites

1.  **Proxy Tool**: Install Charles Proxy, Proxyman, or Requestly on your computer.
2.  **Device/Simulator**:
    *   **iOS Simulator**: Automatically uses the Mac's system proxy.
    *   **Real Device (iOS/Android)**: Configure the Wi-Fi settings to use your computer's IP and the proxy port (e.g., 8888 for Charles, 9090 for Proxyman).
3.  **SSL Proxying**: Ensure your proxy tool has **SSL Proxying enabled** for `*.esmorgaevents.com` (or specifically `qa.api.esmorgaevents.com`). Without this, you will not see the request/response bodies for HTTPS traffic.

## Configuration Details

### 1. Flutter Configuration (`lib/di.dart`)

In `lib/di.dart`, the `HttpClient` is configured for QA builds to:
*   **Detect Proxy**: Uses `http_proxy` package to detect system proxy settings.
*   **Optional Usage**: Checks if a proxy host is configured. If not, it falls back to a standard client, allowing the app to work without a proxy.
*   **Trust Certificates**: Sets `badCertificateCallback` to return `true`, allowing the app to trust the self-signed certificates generated by the proxy tool.

```dart
if (EnvironmentConfig.isQA) {
  final httpProxy = await HttpProxy.createHttpProxy();
  if (httpProxy.host != null && httpProxy.host!.isNotEmpty) {
    HttpOverrides.global = httpProxy;
    final httpClient = HttpClient();
    httpClient.findProxy = (uri) {
      return "PROXY ${httpProxy.host}:${httpProxy.port}";
    };
    httpClient.badCertificateCallback = (X509Certificate cert, String host, int port) {
      return true; // Trust all certs in QA for proxying
    };
    client = IOClient(httpClient);
  } else {
    client = http.Client();
  }
}
```

### 2. Android Configuration

Android 7.0+ (API 24+) requires explicit configuration to trust user-installed certificates.

*   **`android/app/src/main/res/xml/network_security_config.xml`**:
    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <network-security-config>
        <debug-overrides>
            <trust-anchors>
                <certificates src="user" />
                <certificates src="system" />
            </trust-anchors>
        </debug-overrides>
    </network-security-config>
    ```
*   **`android/app/src/main/AndroidManifest.xml`**:
    The `android:networkSecurityConfig` attribute is added to the `<application>` tag:
    ```xml
    <application
        ...
        android:networkSecurityConfig="@xml/network_security_config">
    ```

### 3. iOS Configuration

iOS generally respects the system proxy and user-installed certificates for simulators. For real devices, you must install and trust the certificate.

**Steps to Trust Certificate on iOS (Real Device & Simulator):**
1.  **Install Certificate**: Download the certificate from your proxy tool (e.g., `chls.pro/ssl` for Charles) via Safari on the device.
2.  **Install Profile**: Go to **Settings > General > VPN & Device Management** (or Profiles), tap the downloaded profile, and install it.
3.  **Trust Root Certificate**: Go to **Settings > General > About > Certificate Trust Settings**. Toggle the switch for your proxy's Root Certificate to **ON**.

## Troubleshooting

*   **No Traffic Visible**:
    *   Check if your device/simulator has the proxy configured correctly.
    *   Ensure the app is running in **QA mode** (`EnvironmentConfig.isQA` is true).
*   **HTTPS Requests Fail / No Body Visible**:
    *   **Critical**: Verify **SSL Proxying** is enabled for the domain in your proxy tool.
    *   Ensure the Root Certificate is **fully trusted** on the device (especially step 3 for iOS).

### Interceptors & Client Overrides

If requests are still not appearing or behaving as expected, check for **Interceptors** or **Client Overrides**:

1.  **Interceptors**: Some packages (like `dio` or custom interceptors) might create their own internal `HttpClient`, bypassing the one configured in DI.
    *   **Solution**: Ensure all APIs use the injected `http.Client` instance.
2.  **Client Usage Verification**:
    *   In `lib/di.dart`, verify that the `client` configured with the proxy (lines 84-98) is the one passed to your API classes.
    *   **Correct Wiring**:
        *   `LoggingHttpClient` wraps the proxy-configured `client`.
        *   `EsmorgaAuthApi` and `EsmorgaGuestApi` use the `base` client (LoggingHttpClient).
        *   `AuthenticatedHttpClient` wraps the `base` client.
        *   `EsmorgaApi` uses the `authenticated` client.
    *   **Troubleshooting**: If you suspect an override, add logs in your API classes to print `httpClient.runtimeType`. It should be `LoggingHttpClient` or `AuthenticatedHttpClient`, not a raw `IOClient` or `_HttpClient`.
